<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Syntax Sugar</title>
    <link>http://syntaxsugar.de/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Syntax Sugar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Mar 2017 16:43:13 +0200</lastBuildDate>
    
	<atom:link href="http://syntaxsugar.de/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Reading module and simulation parameters in OMNeT&#43;&#43;</title>
      <link>http://syntaxsugar.de/posts/omnetpp-reading-parameters/</link>
      <pubDate>Wed, 29 Mar 2017 16:43:13 +0200</pubDate>
      
      <guid>http://syntaxsugar.de/posts/omnetpp-reading-parameters/</guid>
      <description>I had a hard time figuring out how to access general simulation parameters such as the maximum simulation time max-sim-time at runtime from whatever module needs it.
For modules it is rather straightforward. From any cModule object, there&amp;rsquo;s a par(const char* parname) function. Say you&amp;rsquo;re writing a module named OmniscientEntity (as I did), and it is defined in OmniscientEntity.ned as this:
simple OmniscientEntity { parameters: // Used for CQI computation. Copy over from your channel.</description>
    </item>
    
    <item>
      <title>Finding equidistant points on a circle</title>
      <link>http://syntaxsugar.de/posts/equidistant-points-on-circle/</link>
      <pubDate>Wed, 29 Mar 2017 11:34:07 +0200</pubDate>
      
      <guid>http://syntaxsugar.de/posts/equidistant-points-on-circle/</guid>
      <description>We know that every circle has \(360\degree = 2\pi\). It&amp;rsquo;s what makes them round.
How can we find the (x,y) positions of n that are evenly distributed on a circle?
Trigonometry to the rescue! All points on a circle are equidistant to the circle&amp;rsquo;s center. All we need to do is go around the circle evenly so that we arrive where we started after n steps.
For this, we put each point at an angle \(\theta\) that goes from 360/n to 360 evenly in n steps:</description>
    </item>
    
    <item>
      <title>Lexicographical index calculation</title>
      <link>http://syntaxsugar.de/posts/lexicographical-index/</link>
      <pubDate>Tue, 28 Mar 2017 14:21:39 +0200</pubDate>
      
      <guid>http://syntaxsugar.de/posts/lexicographical-index/</guid>
      <description>Building upon the idea of word frequency vectors, when implementing the idea in a language of your choice, you might encounter the problem of instantiating a container that is going to store the observed frequencies. In an efficient implementation you could instantiate such a container that holds the right number of items, which is \(\left| \sum_{language} \right| ^n\), e.g. for DNA the alphabet is \(\sum_{DNA}=\{A,C,T,G\}\). \(n\) is the word length for which you&amp;rsquo;re finding the frequency vector.</description>
    </item>
    
  </channel>
</rss>